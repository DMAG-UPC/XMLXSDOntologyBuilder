package org.example.utils;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

import static java.util.Map.entry;

@Slf4j
public class CommonVulnerabilityAndExposureToRequirementLinker {
    public Map<String, Set<String>> getRequirementToCVETypes() throws IOException {
        Map<String, Set<String>> requirementToCVETypes = new HashMap<>();
        try (
            InputStream in = CommonVulnerabilityAndExposureToRequirementLinker.class.getResourceAsStream("/RequirementsToCVETypes.csv");
            BufferedReader reader = new BufferedReader(new InputStreamReader(in))
        ) {
            Iterable<CSVRecord> records = CSVFormat.DEFAULT.builder().setHeader()
                    .setSkipHeaderRecord(true)
                    .build()
                    .parse(reader);

            for (CSVRecord record : records) {
                String requirementName = record.get("RequirementName");
                requirementToCVETypes.put(requirementName, requirementRecordToCVETypes(record));
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        return requirementToCVETypes;
    }

    public static Set<String> requirementRecordToCVETypes(CSVRecord record) {
        var headingToCVEType = Map.ofEntries(
                entry("Overflow", "overflow"),
                entry("Memory corruption", "memc"),
                entry("SQL injection", "sql_injection"),
                entry("XSS", "xss"),
                entry("Directory Traversal", "dir_traversal"),
                entry("File inclusion", "fileinc"),
                entry("CSRF", "csrf"),
                entry("XXE", "xxe"),
                entry("SSRF", "ssrf"),
                entry("Open redirect", "openredir"),
                entry("Input validation", "inputval"),
                entry("Code execution", "execcode"),
                entry("Bypass", "bypass"),
                entry("Privilege Escalation", "gainpriv"),
                entry("Denial of Service", "dos"),
                entry("Information Leak", "infleak")
        );

        Set<String> CVETypes = new HashSet<>();
        for(var entry: headingToCVEType.entrySet()){
            var headingName = entry.getKey();
            var cveType = entry.getValue();
            if (isRequirementRecordAffectedByCVEType(record, headingName)){
                CVETypes.add(cveType);
            }
        }
        return CVETypes;
    }

    private static boolean isRequirementRecordAffectedByCVEType(CSVRecord record, String cveType) {
        try {
            return record.get(cveType).equalsIgnoreCase("TRUE");
        } catch (IllegalArgumentException e) {
            log.warn("CVE type '{}' not found in CSV record. Skipping this type.", cveType);
            return false;
        }
    }

    public static Map<String, List<String>> getCVETypeToCVEs(Path content_folder) {
        Map<String, List<String>> map = new HashMap<>();
        File folder = content_folder.resolve("output/").toFile();


        // Check if the folder exists and is a directory
        if (folder.exists() && folder.isDirectory()) {
            // List all files in the folder
            File[] files = folder.listFiles();

            if (files != null) { // Ensure that the folder is not empty
                for (File file : files) {
                    String fileName = file.getName();
                    String cve_type = fileName
                            .replace(".txt", "")
                            .replace("opt","");
                    List<String> CVEs = map.computeIfAbsent(cve_type, k -> new ArrayList<>());


                    Path filePath = content_folder.resolve("output/").resolve(fileName);

                    try (BufferedReader br = new BufferedReader(new FileReader(filePath.toFile()))) {
                        String line;
                        while ((line = br.readLine()) != null) {
                            CVEs.add(line);
                        }
                    } catch (IOException e) {
                        System.err.println("Error reading the file: " + e.getMessage());
                    }
                }
            }
        } else {
            System.out.println("The specified path is not a directory or does not exist.");
        }

        return map;
    }

    public static void getCVEsOfInterest(
            Set<String> CVEs_of_interest,
            Map<String, Set<String>> requirementToCVETypes,
            Map<String, List<String>> type_to_CVEs,
            InputStream requirementInputStream
    ) throws ParserConfigurationException, SAXException, IOException {
        Document document = readDocument(requirementInputStream);
        NodeList nodes = document.getDocumentElement().getChildNodes();
        for (int i=0; i<nodes.getLength(); i++) {
            Node node = nodes.item(i);
            processInputXMLNode(CVEs_of_interest, requirementToCVETypes, type_to_CVEs, node);
        }
    }

    private static Document readDocument(InputStream requirementInputStream) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(requirementInputStream);
    }

    private static void processInputXMLNode( Set<String> CVEs_of_interest, Map<String, Set<String>> requirementToCVETypes, Map<String, List<String>> type_to_CVEs, Node node) {
        if (!(node instanceof Element requirementNode)) {
            return;
        }
        String requirementName = requirementNode.getElementsByTagName("name").item(0).getTextContent();

        if (!requirementToCVETypes.containsKey(requirementName)) {
            return;
        }
        for (var cveType: requirementToCVETypes.get(requirementName)) {
            if (!type_to_CVEs.containsKey(cveType)) {
                log.debug("No CVEs found for type: {}", cveType);
                continue;
            }
            CVEs_of_interest.addAll(type_to_CVEs.get(cveType));
        }
    }
}
