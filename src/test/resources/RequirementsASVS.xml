<?xml version="1.0" encoding="UTF-8" ?>
<Requirements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="edu.upc.dmag" xsi:schemaLocation="edu.upc.dmag RequirementsSchemas.xsd">

    <!--Chapter 2: Authentication-->
    
    <verification_requirement>
        <name>Requirement for the manufacturer to verify that user-set passwords are at least 12 characters and no more than 128 characters in length</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <constraint>
                <name>user-set password length</name>
                <constrained_action>
                    <name>validating password length</name>
                    <input>
                        <property>
                            <name>user-set password length</name>
                            <Content>
                                <requirement>
                                    <!-- Would be harder to use for automatic tests (compared to purpose build XSD)-->
                                    <name>minimum 12 characters, maximum 128 characters</name>
                                    <requirement_on>
                                        <password>
                                            <name>password length</name>
                                        </password>
                                    </requirement_on>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>validating</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that password truncation is not performed. However, consecutive multiple spaces may be replaced by a single space</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <constraint>
                <name>password truncation and space normalization</name>
                <constrained_action>
                    <name>validating password handling</name>
                    <input>
                        <property>
                            <name>password handling</name>
                            <Content>
                                <requirement>
                                    <name>no truncation of user-set passwords and consecutive multiple spaces may be replaced by a single space</name>
                                    <requirement_on>
                                        <password>
                                            <name>password composition</name>
                                        </password>
                                    </requirement_on>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>validating</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that any printable Unicode character, including spaces and Emojis, is permitted in passwords, without composition rules limiting character types</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>no composition rules limiting character types</name>
                <requirement_on>
                    <password>
                        <name>password characters</name>
                    </password>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify users can change their password and that the password change functionality requires both the user's current and new password</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying password change functionality</name>
            <input_event>
                <change_event>
                    <name>user can change password</name>
                    <change>
                        <name>password change</name>
                        <changed_content>
                            <password>
                                <name>password change requires both the user's current and new password</name>
                            </password>
                        </changed_content>
                    </change>
                </change_event>
            </input_event>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that passwords submitted during account registration, login, and password change are checked against a set of breached passwords</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <!-- This could be easy to have mapped to a user management API-->
            <name>verifying password against breached password list</name>
            <input_event>
                <general_event>
                    <name>account registration, login, and password change</name>
                </general_event>
            </input_event>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that a password strength meter is provided to help users set a stronger password</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <!-- This could be easy to have mapped to a user management API-->
            <requirement>
                <name>strength meter</name>
                <requirement_on>
                    <password>
                        <name>password strength</name>
                    </password>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that there are no periodic credential rotation or password history requirements</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>policy for credential management</name>
                <implemented_content>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API-->
                        <name>no periodic credential rotation or password history requirements</name>
                        <requirement_on>
                            <password>
                                <name>password rotation and history</name>
                            </password>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that paste functionality, browser password helpers, and external password managers are permitted</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements)-->
                <name>paste functionality, browser password helpers, and external password managers are permitted</name>
                <requirement_on>
                    <password>
                        <name>password helpers</name>
                    </password>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that users can temporarily view the entire masked password or the last typed character on platforms without built-in functionality</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <!-- This could be easy to have mapped to a user management API-->
            <name>verifying that users can temporarily view the entire masked password or the last typed character</name>
            <related_action>
                <name>user-set password</name>
                <action_type>registering</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that anti-automation controls (e.g., CAPTCHA, rate limiting) prevent brute force and breached credential attacks, allowing max 100 failed attempts per hour</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <!-- This could be easy to have mapped to a user management API (e.g. fail2ban)-->
                        <name>brute force and breached credential attacks</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_action>
            <name>verifying anti-automation controls prevent brute force and breached credential attacks</name>
            <related_action>
                <name>authentication</name>
                <input>
                    <constraint>
                        <!-- Would be harder to use for automatic tests (compared to purpose build XSD)-->
                        <name>max 100 failed attempts per hour allowed</name>
                        <constrained_action>
                            <name>authentication</name>
                            <action_type>authenticating</action_type>
                        </constrained_action>
                    </constraint>
                </input>
                <action_type>authenticating</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that weak authenticators (SMS, email) are limited to secondary use, stronger methods are prioritized, and users are informed of risks with safeguards in place</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying strong authenticators are prioritized</name>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify secure notifications after updates to authentication details, preferring push notifications, with no sensitive info in SMS or email</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying sending of secure notifications</name>
            <related_action>
                <name>updating authentication details</name>
                <output>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API -->
                        <name>push notifications preferred, no sensitive information in SMS or email</name>
                    </requirement>
                </output>
                <action_type>updating</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify protection against phishing using multi-factor authentication, cryptographic devices, or client-side certificates at higher security levels</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>phishing</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_action>
            <name>verifying protection against phishing</name>
            <related_action>
                <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements)-->
                <name>using multi-factor authentication, cryptographic devices, or client-side certificates at higher security levels</name>
                <action_type>using</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that mutually authenticated TLS is used between a CSP and the application if they are separate</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>mutual authentication for secure communication</name>
                <implemented_content>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements)-->
                        <name>mutually authenticated TLS is used between a CSP and the application if they are separate</name>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify replay resistance by using OTPs, cryptographic authenticators, or lookup codes</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>replay attack</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_action>
            <name>Verify replay resistance mechanisms</name>
            <related_action>
                <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements), problem with "or"-->
                <name>using OTPs, cryptographic authenticators, or lookup codes</name>
                <action_type>using</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify intent to authenticate by requiring an OTP entry or user action like pressing a FIDO hardware key</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verify user intent to authenticate</name>
            <related_action>
                <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements), problem with "or"-->
                <name>using OTP entry or user action like pressing a FIDO hardware key</name>
                <action_type>using</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that initial passwords are securely random, at least 6 characters, may include letters, numbers, expire quickly, and they must not be long-term</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <constraint>
                <name>initial password requirements</name>
                <constrained_action>
                    <name>protect initial password</name>
                    <input>
                        <property>
                            <name>initial password requirements</name>
                            <Content>
                                <requirement>
                                    <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements)-->
                                    <name>securely random, at least 6 characters, may include letters, numbers, expire quickly, and must not be long-term</name>
                                    <requirement_on>
                                        <password>
                                            <name>initial password requirements</name>
                                        </password>
                                    </requirement_on>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>protecting</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that enrollment and use of user-provided authentication devices are supported, such as a U2F or FIDO tokens</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>Support for user-provided authentication devices</name>
                <implemented_content>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API (if broken down in multiple requirements), problem with "or"-->
                        <name>Enrollment and use of user-provided authentication devices, such as U2F or FIDO tokens, must be supported</name>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that renewal instructions are sent with sufficient time to renew time bound authenticators</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying that renewal instructions are sent with sufficient time to renew time bound authenticators</name>
            <output>
                <requirement>
                    <!-- Would be harder to use for automatic tests (compared to purpose build XSD)-->
                    <name>sufficient time to renew time bound authenticators</name>
                </requirement>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify passwords are salted and hashed with a secure function, using a salt and cost factor to resist offline attacks</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <!-- This could be easy to have mapped to a user management API -->
                    <attack_event>
                        <name>offline attack</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <content_implementation>
                <name>salting and hashing password</name>
                <implemented_content>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API -->
                        <name>passwords are salted and hashed with a secure function</name>
                        <requirement_on>
                            <password>
                                <name>salting and hashing</name>
                            </password>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that salts are at least 32 bits long, chosen randomly, and stored uniquely with each hash to prevent collisions</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>collision</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <constraint>
                <name>salt requirements</name>
                <constrained_action>
                    <name>protect password</name>
                    <input>
                        <property>
                            <name>salt requirements</name>
                            <Content>
                                <requirement>
                                        <!-- Would be harder to use for automatic tests (compared to purpose build XSD)-->
                                    <name>at least 32 bits long, chosen randomly, and stored uniquely with each hash</name>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>protecting</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that if PBKDF2 is used, the iteration count should be as large as verification server performance will allow</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>PBKDF2 configuration</name>
                <implemented_content>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API -->
                        <name>PBKDF2 iteration count as large as verification server performance will allow</name>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that if bcrypt is used, the work factor should be as large as verification server performance will allow, with a minimum of 10</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>bcrypt configuration</name>
                <implemented_content>
                    <requirement>
                        <!-- Would be harder to use for automatic tests (compared to purpose build XSD)-->
                        <name>work factor should be as large as verification server performance will allow, with a minimum of 10</name>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify an additional key derivation iteration with a secret salt, generated securely, and stored separately from hashed passwords</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>key derivation configuration</name>
                <implemented_content>
                    <requirement>
                        <!-- This could be easy to have mapped to a user management API -->
                        <name>secret salt, generated securely, and stored separately from hashed passwords</name>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that a system generated initial activation or recovery secret is not sent in clear text to the user</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying system generated initial activation or recovery secret not sent in clear text to user</name>
            <input>
                <component_content>
                    <name>system generated initial activation or recovery secret</name>
                </component_content>
            </input>
            <output>
                <requirement>
                    <name>not sent in clear text to user</name>
                </requirement>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify password hints or knowledge-based authentication (so-called secret questions) are not present</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>password hints or knowledge-based authentication (so-called secret questions) are not present</name>
                <requirement_on>
                    <password>
                        <name>password configuration</name>
                    </password>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify password credential recovery does not reveal the current password in any way</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying password is not revealed</name>
            <related_action>
                <name>password credential recovery</name>
                <action_type>resetting</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify shared or default accounts are not present (e.g. root, admin, or sa)</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>shared or default accounts are not present</name>
                <implemented_content>
                    <requirement>
                        <name>shared or default accounts are not present (e.g. root, admin, or sa)</name>
                        <requirement_on>
                            <general_content>
                                <name>system</name>
                            </general_content>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that if an authentication factor is changed or replaced, that the user is notified of this event</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAlert>
                <communicated_event>
                    <change_event>
                        <name>authentication factor change or replacement</name>
                        <change>
                            <name>authentication factor change or replacement</name>
                            <changed_content>
                                <general_content>
                                    <name>authentication factor</name>
                                </general_content>
                            </changed_content>
                        </change>
                    </change_event>
                </communicated_event>
                <recipient>
                    <name>user</name>
                </recipient>
            </GoalToAlert>
        </goal>
        <verified_action>
            <name>verifying user notification upon authentication factor change</name>
            <related_action>
                <name>notifying user of authentication factor change</name>
                <input>
                    <general_content>
                        <name>authentication factor change event</name>
                    </general_content>
                </input>
                <output>
                    <requirement>
                        <name>notification to user</name>
                    </requirement>
                </output>
                <action_type>communicating</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that password recovery uses secure methods like TOTP, mobile push, or offline mechanisms</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying password recovery uses secure methods</name>
            <related_action>
                <name>using secure methods as TOTP, mobile push, or offline mechanisms</name>
                <action_type>using</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that if OTP or MFA factors are lost, that evidence of identity proofing is performed at the same level as during enrollment</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToEnsureProperty>
                <propertyToEnsure>
                    <name>evidence of identity proofing</name>
                    <Content>
                        <requirement>
                            <name>identity proofing</name>
                        </requirement>
                    </Content>
                </propertyToEnsure>
            </GoalToEnsureProperty>
        </goal>
        <verified_action>
            <name>verifying evidence of identity proofing is performed at the same level as during enrollment</name>
            <related_action>
                <name>identity proofing after loss of OTP or MFA factors</name>
                <action_type>validating</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that lookup secrets can be used only once</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>lookup secrets can be used only once</name>
                <requirement_on>
                    <general_content>
                        <name>lookup secrets</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that lookup secrets have at least 112 bits of entropy, or if less, are salted with a unique 32-bit salt and hashed securely</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <constraint>
                <name>look-up secrets entropy</name>
                <constrained_action>
                    <name>validating look-up secrets entropy</name>
                    <input>
                        <property>
                            <name>look-up secrets entropy</name>
                            <Content>
                                <requirement>
                                    <name>at least 112 bits of entropy, or if less, salted with a unique 32-bit salt and hashed securely</name>
                                    <requirement_on>
                                        <general_content>
                                            <name>lookup secrets</name>
                                        </general_content>
                                    </requirement_on>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>validating</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that lookup secrets are resistant to offline attacks, such as predictable values</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>offline attacks</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <requirement>
                <name>lookup secrets are resistant to offline attacks</name>
                <requirement_on>
                    <general_content>
                        <name>lookup secrets</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that less secure authentication methods like SMS are not default and that stronger options like push notifications are offered first</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying less secure authentication methods are not default</name>
            <related_action>
                <name>using strong authentication methods like push notifications</name>
                <action_type>using</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that the out of band verifier expires out of band authentication requests, codes, or tokens after 10 minutes</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying out of band verifier policy</name>
            <related_action>
                <name>out of band verifier expires out of band authentication requests, codes, or tokens after 10 minutes</name>
                <action_type>revoking</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that out-of-band codes or tokens are single-use and valid only for the original authentication request</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>out of band codes or tokens are single-use and valid only for the original authentication request</name>
                <requirement_on>
                    <general_content>
                        <name>out of band codes or tokens</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that the out of band authenticator and verifier communicates over a secure independent channel</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>out of band authenticator and verifier communicates over a secure independent channel</name>
                <implemented_content>
                    <requirement>
                        <name>communication over a secure independent channel</name>
                        <requirement_on>
                            <general_content>
                                <name>out of band authenticator and verifier</name>
                            </general_content>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that the out of band verifier retains only a hashed version of the authentication code</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>out of band verifier retains only a hashed version of the authentication code</name>
                <implemented_content>
                    <requirement>
                        <name>out of band verifier retains only a hashed version of the authentication code</name>
                        <requirement_on>
                            <general_content>
                                <name>authentication code</name>
                            </general_content>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that initial authentication codes are generated with at least 20 bits of entropy using a secure random number generator</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <constraint>
                <name>initial authentication codes</name>
                <constrained_action>
                    <name>validating initial authentication codes policy</name>
                    <input>
                        <property>
                            <name>initial authentication codes policy</name>
                            <Content>
                                <requirement>
                                    <name>at least 20 bits of entropy using a secure random number generator</name>
                                    <requirement_on>
                                        <general_content>
                                            <name>initial authentication codes</name>
                                        </general_content>
                                    </requirement_on>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>validating</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that time-based OTPs have a defined lifetime before expiring</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>time-based OTPs have a defined lifetime before expiring</name>
                <requirement_on>
                    <general_content>
                        <name>time-based OTPs</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that symmetric keys used to verify submitted OTPs are highly protected</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>symmetric keys used to verify submitted OTPs are highly protected</name>
                <requirement_on>
                    <general_content>
                        <name>symmetric keys</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that approved cryptographic algorithms are used in the generation, seeding, and verification of OTPs</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>approved cryptographic algorithms used in the generation, seeding, and verification of OTPs</name>
                <requirement_on>
                    <general_content>
                        <name>OTPs</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that time-based OTP can be used only once within the validity period</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>time-based OTP can be used only once within the validity period</name>
                <requirement_on>
                    <general_content>
                        <name>time-based OTP</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that if a time-based multi-factor OTP token is re-used during the validity period, it is logged and rejected with notifications to the device holder</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAlert>
                <communicated_event>
                    <compromission_event>
                        <name>reuse of a time-based multi-factor OTP token is re-used during the validity period</name>
                        <compromised_content>
                            <general_content>
                                <name>time-based multi-factor OTP token</name>
                            </general_content>
                        </compromised_content>
                    </compromission_event>
                </communicated_event>
                <recipient>
                    <name>user</name>
                </recipient>
            </GoalToAlert>
        </goal>
        <verified_action>
            <name>verifying time-based multi-factor OTP token reuse policy</name>
            <related_action>
                <name>logging and rejecting re-used OTP token with notifications</name>
                <action_type>revoking</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that a stolen physical OTP generator can be revoked immediately, affecting all active sessions regardless of location</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying stolen physical OTP generator can be revoked immediately</name>
            <input_event>
                <compromission_event>
                    <name>physical OTP generator theft</name>
                    <compromised_content>
                        <general_content>
                            <name>OTP</name>
                        </general_content>
                    </compromised_content>
                </compromission_event>
            </input_event>
            <output>
                <general_content>
                    <name>immediate revocation, affecting all active sessions regardless of location</name>
                </general_content>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that biometric authenticators are used only as secondary factors, alongside something you have and something you know</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>biometric authenticators</name>
                <implemented_content>
                    <requirement>
                        <name>biometric authenticators used only as secondary factors, alongside something you have and something you know</name>
                        <requirement_on>
                            <general_content>
                                <name>biometric authenticators</name>
                            </general_content>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that cryptographic keys used in verification are stored securely and protected against disclosure</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>disclosure</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <requirement>
                <name>cryptographic keys used in verification are stored securely</name>
                <requirement_on>
                    <general_content>
                        <name>cryptographic keys</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that the challenge nonce is at least 64 bits in length, and statistically unique or unique over the lifetime of the cryptographic device</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <constraint>
                <name>challenge nonce length</name>
                <constrained_action>
                    <name>validating challenge nonce length</name>
                    <input>
                        <property>
                            <name>challenge nonce length</name>
                            <Content>
                                <requirement>
                                    <name>minimum 64 bits, statistically unique or unique over the lifetime of the cryptographic device</name>
                                    <requirement_on>
                                        <password>
                                            <name>password length</name>
                                        </password>
                                    </requirement_on>
                                </requirement>
                            </Content>
                        </property>
                    </input>
                    <action_type>validating</action_type>
                </constrained_action>
            </constraint>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that approved cryptographic algorithms are used in the generation, seeding, and verification</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>approved cryptographic algorithms used in the generation, seeding, and verification</name>
                <requirement_on>
                    <general_content>
                        <name>cryptographic verifier</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that intra-service secrets do not rely on unchanging credentials (HSM)</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>intra-service secrets do not rely on unchanging credentials</name>
                <requirement_on>
                    <general_content>
                        <name>intra-service secrets</name>
                    </general_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that if passwords are required for service authentication, the service account used is not a default credential (HSM)</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <requirement>
                <name>service account used is not a default credential</name>
                <requirement_on>
                    <password>
                        <name>service authentication</name>
                    </password>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that passwords are stored with sufficient protection to prevent offline recovery attacks (HSM)</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>offline recovery attacks</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <requirement>
                <name>passwords are stored with sufficient protection</name>
                <requirement_on>
                    <password>
                        <name>password storage</name>
                    </password>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify passwords, API keys, and secrets are securely stored, not in source code, using HSM to resist offline attacks (HSM)</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>offline attacks</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <content_implementation>
                <name>HSM</name>
                <implemented_content>
                    <requirement>
                        <name>passwords, API keys, and secrets are securely stored, not in source code, using HSM</name>
                        <requirement_on>
                            <general_content>
                                <name>passwords, API keys, and secrets</name>
                            </general_content>
                        </requirement_on>
                    </requirement>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>
    
    <!--Chapter 3: Session Management-->
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the application never reveals session tokens in URL parameters</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying session token exposure</name>
            <related_action>
                <name>session token management</name>
                <input>
                    <component_content>
                        <name>session tokens</name>
                    </component_content>
                </input>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <component_content>
                    <name>session tokens not exposed in URL parameters</name>
                    <goal>
                        <GoalToAvoidEvent>
                            <eventToAvoid>
                                <content_identification_event>
                                    <name>session token exposure in URL parameters</name>
                                    <identified>
                                        <risk>
                                            <name>session token exposure</name>
                                            <unacceptable>true</unacceptable>
                                        </risk>
                                    </identified>
                                </content_identification_event>
                            </eventToAvoid>
                        </GoalToAvoidEvent>
                    </goal>
                </component_content>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the application generates a new session token on user authentication</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying session token generation</name>
            <related_action>
                <name>user authentication</name>
                <input>
                    <component_content>
                        <name>user credentials</name>
                    </component_content>
                </input>
                <action_type>authenticating</action_type>
            </related_action>
            <output>
                <component_content>
                    <name>new session token generated</name>
                </component_content>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that session tokens possess at least 64 bits of entropy</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <property>
                <name>session tokens entropy</name>
                <Content>
                    <requirement>
                        <name>at least 64 bits</name>
                    </requirement>
                </Content>
            </property>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the application only stores session tokens in the browser using secure methods such as appropriately secured cookies or HTML 5 session storage</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying session token storage methods</name>
            <related_action>
                <name>session token storage</name>
                <input>
                    <component_content>
                        <name>session tokens</name>
                    </component_content>
                </input>
                <action_type>storing</action_type>
            </related_action>
            <output>
                <verification>
                    <name>session tokens stored in the browser using secure methods</name>
                    <verficiation_of>
                        <component_content>
                            <name>session tokens</name>
                        </component_content>
                    </verficiation_of>
                </verification>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that session tokens are generated using approved cryptographic algorithms</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying session token generation</name>
            <related_action>
                <name>session token management</name>
                <input>
                    <component_content>
                        <name>session tokens</name>
                    </component_content>
                </input>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <usage>
                    <name>session tokens generation using approved cryptographic algorithms</name>
                    <usage_of>
                        <content_implementation>
                            <name>session token generation</name>
                            <implemented_content>
                                <component_content>
                                    <name>approved cryptographic algorithms</name>
                                </component_content>
                            </implemented_content>
                        </content_implementation>
                    </usage_of>
                </usage>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that logout and expiration invalidate the session token, preventing session resume via the back button or other relying parties</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying session token invalidation</name>
            <related_action>
                <name>session token management</name>
                <input>
                    <component_content>
                        <name>session tokens</name>
                    </component_content>
                </input>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <verification>
                    <name>logout and expiration invalidate the session token</name>
                    <verficiation_of>
                        <component_content>
                            <name>session token invalidation</name>
                            <goal>
                                <GoalToAvoidEvent>
                                    <eventToAvoid>
                                        <content_identification_event>
                                            <name>session resume via the back button or other relying parties</name>
                                            <identified>
                                                <risk>
                                                    <name>unauthorized session resume</name>
                                                    <unacceptable>true</unacceptable>
                                                </risk>
                                            </identified>
                                        </content_identification_event>
                                    </eventToAvoid>
                                </GoalToAvoidEvent>
                            </goal>
                        </component_content>
                    </verficiation_of>
                </verification>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify re-authentication with 2FA occurs every 12 hours of active use or after 15 minutes of inactivity, if authenticators permit users to remain logged in</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <condition>if authenticators permit users to remain logged in</condition>
        <verified_action>
            <name>verifying re-authentication with 2FA after 12 hours of active use or 15 minutes of inactivity</name>
            <related_action>
                <name>authentication management</name>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <verification>
                    <name>re-authentication with 2FA every 12 hours or after 15 minutes of inactivity</name>
                    <verficiation_of>
                        <component_content>
                            <name>re-authentication</name>
                            <goal>
                                <GoalToAvoidEvent>
                                    <eventToAvoid>
                                        <general_event>
                                            <name>unauthorized access</name>
                                        </general_event>
                                    </eventToAvoid>
                                </GoalToAvoidEvent>
                            </goal>
                        </component_content>
                    </verficiation_of>
                </verification>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the app allows terminating all active sessions after a password change, including federated logins and relying parties</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <condition>password change</condition>
        <verified_action>
            <name>verifying session termination after password change</name>
            <related_action>
                <name>session management</name>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <verification>
                    <name>termination of all active sessions</name>
                    <verficiation_of>
                        <component_content>
                            <name>session management</name>
                        </component_content>
                    </verficiation_of>
                </verification>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify users can view and log out of any or all active sessions and devices by re-entering their login credentials</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying session management functionalities</name>
            <related_action>
                <name>session management</name>
                <input>
                    <actor>
                        <name>user</name>
                    </actor>
                </input>
                <input>
                    <component_content>
                        <name>login credentials</name>
                    </component_content>
                </input>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <verification>
                    <name>view and logout of active sessions</name>
                    <verficiation_of>
                        <component_content>
                            <name>session management</name>
                        </component_content>
                    </verficiation_of>
                </verification>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that cookie-based session tokens have the 'Secure' attribute set</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>cookie-based session tokens</name>
                <implemented_content>
                    <component_content>
                        <name>'Secure' attribute required</name>
                    </component_content>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that cookie-based session tokens have the 'HttpOnly' attribute set</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_content>
            <content_implementation>
                <name>cookie-based session tokens</name>
                <implemented_content>
                    <component_content>
                        <name>'HttpOnly' attribute required</name>
                    </component_content>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that cookie-based session tokens utilize the 'SameSite' attribute to limit exposure to cross-site request forgery attacks</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>cross-site request forgery attacks</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <content_implementation>
                <name>cookie-based session tokens</name>
                <implemented_content>
                    <component_content>
                        <name>'SameSite' attribute required</name>
                    </component_content>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that cookie-based session tokens use the '__Host-' prefix so cookies are only sent to the host that initially set the cookie</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <EnsuringProperty>
                <name>cookies are only sent to the host that initially set the cookie</name>
                <Content>
                    <verification>
                        <name>cookies are only sent to the host that initially set the cookie</name>
                        <verficiation_of>
                            <component_content>
                                <name>cookies</name>
                            </component_content>
                        </verficiation_of>
                    </verification>
                </Content>
            </EnsuringProperty>
        </goal>
        <verified_content>
            <content_implementation>
                <name>cookie-based session tokens</name>
                <implemented_content>
                    <component_content>
                        <name>'__Host-' prefix</name>
                    </component_content>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that session cookies use the most precise path attribute possible to limit access to the specific application, especially on shared domains</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <security_related_incident>
                        <name>unauthorized access</name>
                    </security_related_incident>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <content_implementation>
                <name>session cookies</name>
                <implemented_content>
                    <component_content>
                        <name>precise path attribute</name>
                    </component_content>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the application allows users to revoke OAuth tokens that form trust relationships with linked applications</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying OAuth token revocation</name>
            <related_action>
                <name>token management</name>
                <input>
                    <component_content>
                        <name>OAuth tokens</name>
                    </component_content>
                </input>
                <action_type>managing</action_type>
            </related_action>
            <output>
                <component_content>
                    <!-- problem: does not sound like a component -->
                    <name>revoke OAuth tokens that form trust relationships with linked applications</name>
                </component_content>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the application uses session tokens rather than static API secrets and keys, except with legacy implementations</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <condition>except with legacy implementations</condition>
        <verified_content>
            <content_implementation>
                <name>token-based session management</name>
                <implemented_content>
                    <component_content>
                        <name>session tokens</name>
                        <secure>true</secure>
                    </component_content>
                </implemented_content>
            </content_implementation>
        </verified_content>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that stateless session tokens use digital signatures, encryption, and other measures to guard against tampering, replay, and key substitution attacks</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <goal>
            <GoalToAvoidEvent>
                <eventToAvoid>
                    <attack_event>
                        <name>tampering, enveloping, null cipher, replay, and key substitution attacks</name>
                    </attack_event>
                </eventToAvoid>
            </GoalToAvoidEvent>
        </goal>
        <verified_content>
            <requirement>
                <name>use of digital signatures, encryption, and other measures</name>
                <requirement_on>
                    <component_content>
                        <name>stateless session tokens</name>
                    </component_content>
                </requirement_on>
            </requirement>
        </verified_content>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify Relying Parties set a maximum authentication time, and CSPs re-authenticate users if the session is inactive beyond this period</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <condition>if the session is inactive beyond a maximum authentication time</condition>
        <when>
            <event>
                <general_event>
                    <name>session is inactive beyond Relying Parties' maximum authentication time</name>
                </general_event>
            </event>
        </when>
        <verified_action>
            <name>verifying session management</name>
            <related_action>
                <!-- action not ending in "ing" -->
                <name>CSPs re-authenticate users</name>
                <action_type>authenticating</action_type>
            </related_action>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

    <verification_requirement>
        <name>Requirement that the manufacturer shall verify that CSPs inform Relying Parties of the last authentication event to help determine if re-authentication is needed</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying CSPs inform Relying Parties of the last authentication event</name>
            <related_action>
                <name>ensuring Relying Parties is informed</name>
                <input>
                    <component_content>
                        <name>last authentication event</name>
                    </component_content>
                </input>
                <action_type>ensuring</action_type>
            </related_action>
            <output>
                <component_content>
                    <!-- problem with 'or' -->
                    <name>determine if re-authentication is needed</name>
                </component_content>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>
    
    <verification_requirement>
        <name>Requirement that the manufacturer shall verify the application requires a full login session or re-authentication for sensitive transactions or account modifications</name>
        <actor>
            <name>manufacturer</name>
        </actor>
        <verified_action>
            <name>verifying full login or re-authentication for sensitive transactions or account modifications</name>
            <input>
                <content_implementation>
                    <name>session management</name>
                    <implemented_content>
                        <component_content>
                            <!-- problem with 'or' -->
                            <name>login session or re-authentication</name>
                        </component_content>
                    </implemented_content>
                </content_implementation>
            </input>
            <output>
                <verification>
                    <name>session management</name>
                    <verficiation_of>
                        <component_content>
                            <!-- problem with 'or' -->
                            <name>sensitive transactions or account modifications</name>
                        </component_content>
                    </verficiation_of>
                </verification>
            </output>
            <action_type>verifying</action_type>
        </verified_action>
    </verification_requirement>

</Requirements>